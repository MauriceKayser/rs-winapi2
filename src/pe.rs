//! All types for parsing a PE file.
//!
//! Based on: https://docs.microsoft.com/en-us/windows/win32/debug/pe-format
//!
//! Use the `PeFile` type to get information about a PE file.

use core::convert::TryFrom;
use core::mem::size_of;

/// An iterator over the exported functions of a PE file.
pub struct ExportIterator<'a, 'b> {
    image: &'b mut PeFile<'a>,
    exclude_zero_terminator: bool,
    directory: &'a ExportDirectory,
    directory_size: u32,

    address_rvas: &'a [u32],
    name_rvas: &'a [u32],
    ordinals: &'a [u16],
    ordinal_base: u32,

    index: usize
}

impl<'a, 'b> ExportIterator<'a, 'b> {
    /// Creates an iterator over the exported functions of a PE file.
    #[cfg_attr(not(debug_assertions), inline(always))]
    pub fn new(pe: &'b mut PeFile<'a>, exclude_zero_terminator: bool) -> Option<Self> {
        let (directory, directory_size) = pe.directory_export()?;

        let addresses_offset = pe.rva_to_offset(directory.addresses_rva);
        let names_offset = pe.rva_to_offset(directory.names_rva);
        let ordinals_offset = pe.rva_to_offset(directory.ordinals_rva);

        let addresses_max = pe.maximum_rest_of::<u32>(addresses_offset)?;
        let names_max = pe.maximum_rest_of::<u32>(names_offset)?;
        let ordinals_max = pe.maximum_rest_of::<u16>(ordinals_offset)?;

        unsafe {
            Some(Self {
                directory,
                directory_size,
                address_rvas: pe.slice_unchecked(
                    addresses_offset,
                    core::cmp::min(directory.addresses_count as usize, addresses_max)
                ),
                name_rvas: pe.slice_unchecked(
                    names_offset,
                    core::cmp::min(directory.names_count as usize, names_max)
                ),
                ordinals: pe.slice_unchecked(
                    ordinals_offset,
                    core::cmp::min(directory.names_count as usize, ordinals_max)
                ),
                ordinal_base: directory.ordinal_base,
                index: 0,
                image: pe,
                exclude_zero_terminator
            })
        }
    }
}

impl<'a, 'b> core::iter::Iterator for ExportIterator<'a, 'b> {
    type Item = ExportNamed<'a>;

    fn next(&mut self) -> Option<Self::Item> {
        let dir_offset = self.image.offset_of(self.directory);

        loop { unsafe {
            // Terminate the iterator, if the ordinal- or name index is out of bounds.
            let ordinal = self.ordinals.get(self.index)?;
            let name_offset = self.image.rva_to_offset(*self.name_rvas.get_unchecked(self.index));

            self.index += 1;

            // Skip this export, if the possible name length is <= 0.
            let max_name_len = match (self.image.image_base.len() as u32).checked_sub(name_offset) {
                Some(len) if len > 0 => core::num::NonZeroUsize::new_unchecked(len as usize),
                _ => continue
            };

            // Skip this export, if the ordinal overflows.
            let biased_ordinal = match self.ordinal_base.checked_add(*ordinal as u32) {
                Some(ord) => ord,
                _ => continue
            };

            // Skip this export, if the ordinal is out of bounds.
            let (address_rva, address_offset) = match self.address_rvas.get(*ordinal as usize) {
                Some(rva) => (rva, self.image.rva_to_offset(*rva)),
                None => continue
            };

            // Construct the export name.
            let name = crate::string::AnsiStr::from_terminated_with_offset(
                self.image.image_base.as_ptr(),
                name_offset as usize,
                Some(max_name_len),
                self.exclude_zero_terminator
            );

            // Is the offset not in bounds of the export directory?
            if !(dir_offset..=dir_offset.unchecked_add(self.directory_size)).contains(&address_offset) {
                // Then it is a real export.

                // Check if the offset is inside the PE file.
                if (address_offset as usize) < self.image.image_base.len() {
                    let buffer = self.image.slice_unchecked(
                        address_offset,
                        self.image.image_base.len() - address_offset as usize
                    );
                    // let address = &*self.image.offset_to_ptr(address_offset);

                    return Some(ExportNamed {
                        data: ExportData::InModule(buffer), name, address_rva, ordinal: biased_ordinal
                    });
                } else {
                    let address = self.image.offset_to_ptr(address_offset);

                    return Some(ExportNamed {
                        data: ExportData::OutOfModule(address), name, address_rva, ordinal: biased_ordinal
                    });
                }
            } else {
                // Otherwise it is a forwarded export.

                // Skip this export, if the possible forwarded name length is <= 0.
                let fwd_name_len = match self.image.image_base.len().checked_sub(address_offset as usize) {
                    Some(len) if len > 0 => core::num::NonZeroUsize::new_unchecked(len),
                    _ => continue
                };

                // Construct the forwarded name.
                let fwd_name = crate::string::AnsiStr::from_terminated_with_offset(
                    self.image.image_base.as_ptr(),
                    address_offset as usize,
                    Some(fwd_name_len),
                    self.exclude_zero_terminator
                );

                return Some(ExportNamed {
                    data: ExportData::Forwarded(fwd_name), name, address_rva, ordinal: biased_ordinal
                });
            }
        } }
    }
}

/// Stores the data which an export points at.
#[cfg_attr(debug_assertions, derive(Debug, Eq, PartialEq))]
pub enum ExportData<'a> {
    /// Data or a function in the PE file buffer.
    InModule(&'a [u8]),

    /// Data or a function outside of the PE file buffer.
    OutOfModule(*const u8),

    /// The name of the forwarded symbol.
    Forwarded(&'a crate::string::AnsiStr)
}

/// Stores details about an export by a PE file.
#[cfg_attr(debug_assertions, derive(Debug, Eq, PartialEq))]
pub struct ExportNamed<'a> {
    /// The data which the export points at.
    pub data: ExportData<'a>,

    /// The ASCII encoded, zero-terminated export name.
    pub name: &'a crate::string::AnsiStr,

    /// The reference to the address RVA.
    pub address_rva: &'a u32,

    /// The ordinal number of the export.
    pub ordinal: u32
}

/// A parser for PE files.
pub struct PeFile<'a> {
    image_base: &'a [u8],
    mode: ParsingMode,
    image_machine_type: Option<CoffMachine>,
    size_after_optional_header: Option<u16>,
    directories: Option<&'a [DataDirectory]>
}

impl<'a> PeFile<'a> {
    /// Creates a new PE file parser.
    #[cfg_attr(not(debug_assertions), inline(always))]
    pub fn new(image_base: &'a [u8], mode: ParsingMode) -> Self {
        Self {
            image_base,
            mode,
            image_machine_type: None,
            size_after_optional_header: None,
            directories: None
        }
    }

    /// Creates an iterator over the functions the PE file exports.
    #[cfg_attr(not(debug_assertions), inline(always))]
    pub fn exports<'b>(&'b mut self, exclude_zero_terminator: bool) -> Option<ExportIterator<'a, 'b>> {
        ExportIterator::new(self, exclude_zero_terminator)
    }

    /// Returns and caches the machine type of the PE file.
    #[cfg_attr(not(debug_assertions), inline(always))]
    pub fn machine_type(&mut self) -> Option<CoffMachine> {
        self.image_machine_type.or_else(|| self.coff_header().and_then(|header| {
            // Cache the machine type.
            let machine = CoffMachine::try_from(header.machine).ok();
            self.image_machine_type = machine;

            machine
        }))
    }

    // -- Private methods --

    #[cfg_attr(not(debug_assertions), inline(always))]
    fn coff_header(&self) -> Option<&'a CoffHeader> {
        let header = unsafe { crate::conversion::cast::<CoffHeader>(
            self.image_base, self.dos_header()?.coff_fo as usize
        )? };

        if header.magic != CoffHeaderMagic::Coff as u32 {
            return None;
        }

        Some(header)
    }

    #[cfg_attr(not(debug_assertions), inline(always))]
    fn dos_header(&self) -> Option<&'a DosHeader> {
        let header = unsafe { crate::conversion::cast::<DosHeader>(
            self.image_base, 0
        )? };

        if header.magic != DosHeaderMagic::Dos as u16 {
            return None;
        }

        Some(header)
    }

    #[cfg_attr(not(debug_assertions), inline(always))]
    fn directory(&mut self, dir: DataDirectoryType) -> Option<&'a DataDirectory> {
        // Get result from cache.
        if let Some(directories) = self.directories {
            return directories.get(dir as usize);
        }

        // Cache the data directories.
        unsafe {
            // The data directories follow directly after the optional header.
            let (count, after_header_offset) = match self.optional_header()? {
                OptionalHeader::Pe64(header) => (
                    header.data_directory_count,
                    self.offset_after(header)
                ),

                OptionalHeader::Pe32(header) => (
                    header.data_directory_count,
                    self.offset_after(header)
                )
            };

            let directories_max = self.maximum_rest_of::<DataDirectory>(after_header_offset)?;

            self.directories = Some(self.slice_unchecked(
                after_header_offset, core::cmp::min(count as usize, directories_max)
            ));

            self.directories.unwrap_unchecked().get(dir as usize)
        }
    }

    #[cfg_attr(not(debug_assertions), inline(always))]
    fn directory_export(&mut self) -> Option<(&'a ExportDirectory, u32)> {
        let dir = self.directory(DataDirectoryType::Export)?;

        if size_of::<ExportDirectory>() > dir.size as usize {
            return None;
        }

        let export = unsafe { crate::conversion::cast::<ExportDirectory>(
            self.image_base, self.rva_to_offset(dir.rva) as usize
        )? };

        // Optionally shrink `dir.size` to the end of the buffer.
        let dir_offset = self.offset_of(export);
        let directory_to_buffer_end_length = unsafe {
            (self.image_base.len() as u32).unchecked_sub(dir_offset)
        };

        Some((export, core::cmp::min(dir.size, directory_to_buffer_end_length)))
    }

    #[cfg_attr(not(debug_assertions), inline(always))]
    fn optional_header(&mut self) -> Option<OptionalHeader<'a>> {
        let coff_header = self.coff_header()?;

        // Validate and cache the image machine type.
        if self.image_machine_type.is_none() {
            self.image_machine_type = Some(CoffMachine::try_from(coff_header.machine).ok()?);
        }

        // The optional header follows directly after the COFF header.
        let header_offset = unsafe { self.offset_after(coff_header) };

        let (optional_header, optional_header_size) =
            match unsafe { self.image_machine_type.unwrap_unchecked() }
        {
            CoffMachine::Amd64 => {
                let header = unsafe { crate::conversion::cast::<OptionalHeader64>(
                    self.image_base, header_offset as usize
                )? };

                if header.magic != OptionalHeaderMagic::Pe64 as u16 {
                    return None;
                }

                (OptionalHeader::Pe64(header), size_of::<OptionalHeader64>())
            },

            CoffMachine::I386 => {
                let header = unsafe { crate::conversion::cast::<OptionalHeader32>(
                    self.image_base, header_offset as usize
                )? };

                if header.magic != OptionalHeaderMagic::Pe32 as u16 {
                    return None;
                }

                (OptionalHeader::Pe32(header), size_of::<OptionalHeader32>())
            }
        };

        // Validate and cache the optional header size.
        if self.size_after_optional_header.is_none() {
            self.size_after_optional_header = Some(core::cmp::min(
                coff_header.optional_header_size as usize,
                unsafe { self.image_base.len().unchecked_sub(header_offset as usize) }
            ).checked_sub(optional_header_size)? as u16);
        }



        Some(optional_header)
    }

    #[cfg_attr(not(debug_assertions), inline(always))]
    fn rva_to_offset(&self, rva: u32) -> u32 {
        match self.mode {
            ParsingMode::Virtual => rva
        }
    }

    // -- Helper methods --

    /// Calculates the amount of `T` that fit into the buffer after the specified offset.
    #[cfg_attr(not(debug_assertions), inline(always))]
    fn maximum_rest_of<T>(&self, offset: u32) -> Option<usize> {
        use core::ops::Div;

        Some(
            self.image_base.len()
                .checked_sub(offset as usize)? // Rest of the buffer.
                .div(size_of::<T>()) // Convert buffer length to T count.
        )
    }

    /// Returns the offset after the type `T` which is part of the image buffer.
    #[cfg_attr(not(debug_assertions), inline(always))]
    unsafe fn offset_after<T>(&self, data: &'a T) -> u32 {
        (data as *const _ as usize)
            .unchecked_sub(self.image_base.as_ptr() as usize) // Offset of `data`.
            .unchecked_add(size_of::<T>()) as u32 // Offset after `data`.
    }

    /// Returns the offset of the type `T` which is part of the image buffer.
    #[cfg_attr(not(debug_assertions), inline(always))]
    fn offset_of<T>(&self, data: &'a T) -> u32 {
        unsafe {
            (data as *const _ as usize)
                .unchecked_sub(self.image_base.as_ptr() as usize) as u32 // Offset of `data`.
        }
    }

    /// Converts an offset into a pointer of `T` in the buffer.
    #[cfg_attr(not(debug_assertions), inline(always))]
    unsafe fn offset_to_ptr<T>(&self, offset: u32) -> *const T {
        (self.image_base.as_ptr() as usize).unchecked_add(offset as usize) as _
    }

    /// Forms a slice of `T` from an offset and a length.
    #[cfg_attr(not(debug_assertions), inline(always))]
    unsafe fn slice_unchecked<T>(&self, offset: u32, len: usize) -> &'a [T] {
        core::slice::from_raw_parts(
            (self.image_base.as_ptr() as usize).unchecked_add(offset as usize) as *const _,
            len
        )
    }
}

/// The way the PE file is laid out in memory.
#[derive(Eq, PartialEq)]
pub enum ParsingMode {
    // TODO: Implement `ParsingMode::File`.
    // /// Read from the raw file on disk.
    // File,

    /// The sections are mapped at their virtual offsets instead of their file offsets.
    Virtual
}

// -- PE file format data types below --

#[allow(missing_docs)]
#[repr(C)]
struct CoffHeader {
    magic: u32,
    machine: u16,
    _1: [u8; 14],
    optional_header_size: u16,
    _2: [u8; 2]
}

#[repr(u32)]
enum CoffHeaderMagic {
    Coff = 0x00004550
}

/// The CPU type which the PE file was compiled for.
#[allow(missing_docs)]
#[derive(Clone, Copy, bitfield::FromPrimitive)]
#[repr(u16)]
pub enum CoffMachine {
    Amd64 = 0x8664,
    I386 = 0x014C
}

#[repr(C)]
struct DataDirectory {
    rva: u32,
    size: u32
}

#[allow(unused)]
#[cfg_attr(debug_assertions, derive(Debug))]
#[derive(Clone, Copy)]
#[repr(C)]
enum DataDirectoryType {
    Export,
    Import,
    Resource,
    Exception,
    Certificate,
    BaseRelocation,
    Debug,
    Architecture,
    GlobalPointer,
    ThreadLocalStorage,
    LoadConfig,
    BoundImport,
    ImportAddress,
    DelayImport,
    CommonLanguageRuntime,
    Reserved
}

#[allow(missing_docs)]
#[repr(C)]
pub struct DosHeader {
    magic: u16,
    _1: [u8; 0x3A],
    coff_fo: u32
}

impl DosHeader {
    /// Creates a new PE file parser.
    ///
    /// `image_size` refers to the size of the memory buffer, which is the raw file size in the
    /// `mode` `File` and the virtual size in the mode `Virtual`.
    #[cfg_attr(not(debug_assertions), inline(always))]
    pub fn create_parser(&self, image_size: u32, mode: ParsingMode) -> Option<PeFile> {
        (size_of::<Self>() <= image_size as usize).then(
            || PeFile::new(unsafe { core::slice::from_raw_parts(
                self as *const DosHeader as *const _, image_size as usize
            ) }, mode)
        )
    }
}

#[repr(u16)]
enum DosHeaderMagic {
    Dos = 0x5A4D
}

#[repr(C)]
struct ExportDirectory {
    _1: [u8; 16],
    ordinal_base: u32,
    addresses_count: u32,
    names_count: u32,
    addresses_rva: u32,
    names_rva: u32,
    ordinals_rva: u32
}

enum OptionalHeader<'a> {
    Pe32(&'a OptionalHeader32),
    Pe64(&'a OptionalHeader64)
}

#[repr(C)]
struct OptionalHeader32 {
    magic: u16,
    _1: [u8; 0x5A],
    data_directory_count: u32
}

#[repr(C)]
struct OptionalHeader64 {
    magic: u16,
    _1: [u8; 0x6A],
    data_directory_count: u32
}

#[repr(u16)]
enum OptionalHeaderMagic {
    Pe32 = 0x010B,
    Pe64 = 0x020B
}

#[cfg(test)]
mod tests {
    use super::*;

    // Macros.

    macro_rules! parse {
        ( $( ($name:expr, $mode:ident, $parser:ident, $valid:expr, $buffer:expr) ),+ ) => {
            $(
                parse!($name, $mode, $parser, $valid, $buffer);
            )+
        };
        ($name:expr, $mode:ident, $parser:ident, $valid:expr, $buffer:expr) => {{
            assert_eq!(
                PeFile::new($buffer, ParsingMode::$mode).$parser().is_some(),
                $valid,
                "unexpected parsing result for {:?}", $name
            );
        }};
    }

    macro_rules! parse_exports {
        ( $( ($name:expr, $mode:ident, $result:expr, $buffer:expr) ),+ ) => {
            $(
                parse_exports!($name, $mode, $result, $buffer);
            )+
        };
        ($name:expr, $mode:ident, $result:expr, $buffer:expr) => {{
            assert_eq!(
                PeFile::new($buffer, ParsingMode::$mode).exports(true).unwrap().collect::<alloc::vec::Vec<ExportNamed>>(),
                $result,
                "unexpected parsing result for {:?}", $name
            );
        }};
    }

    // Test macros.

    #[test]
    #[should_panic(expected = "unexpected parsing result for \"Empty file\"")]
    fn validate_parse() {
        parse!("Empty file", Virtual, dos_header, true, &[]);
    }

    #[test]
    #[should_panic(expected = "unexpected parsing result for \"No exports\"")]
    fn validate_parse_exports() {
        const BUFFER: &[u8] = &[
            0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x28,0x00,
            0x00,0x00
        ];

        parse_exports!("No exports", Virtual, &[
            ExportNamed {
                data: ExportData::Forwarded(From::from("A".as_bytes())),
                name: From::from("B".as_bytes()),
                address_rva: unsafe { &*(BUFFER.as_ptr() as *const u32) },
                ordinal: 0
            }
        ], BUFFER);
    }

    // Test code.

    #[test]
    fn exports() {
        const BUFFER: &[u8] = &[
            /*  00 */ 0x4D,0x5A,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, // DH.magic = 0x5A4D
            /*  10 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  20 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  30 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x40,0x00,0x00,0x00, // DH.coff_fo = 0x40
            /*  40 */ 0x50,0x45,0x00,0x00, 0x64,0x86,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, // CH.magic = 0x4550, CH.machine = 0x8664
            /*  50 */ 0x00,0x00,0x00,0x00, 0x78,0x00,0x00,0x00, 0x0B,0x02,0x00,0x00, 0x00,0x00,0x00,0x00, // CH.optional_header_size = 0x78, OH64.magic = 0x020B
            /*  60 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  70 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  80 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  90 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  A0 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  B0 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  C0 */ 0x00,0x00,0x00,0x00, 0x01,0x00,0x00,0x00, 0xD0,0x00,0x00,0x00, 0x4F,0x00,0x00,0x00, // OH64.data_directory_count = 1, Dir(Export).rva = 0xD0, Dir(Export).size = 0x28 + 3*4 + 3*4 + 3*2 + len("A\0") + len("B\0") + len("C.D\0") + len("E\0") = 0x4F
            /*  D0 */ 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
            /*  E0 */ 0x00,0x00,0x00,0x00, 0x03,0x00,0x00,0x00, 0x03,0x00,0x00,0x00, 0xF8,0x00,0x00,0x00, // EDir.ordinal_base: 0, EDir.addrs: 3, EDir.names: 3, EDir.addr_rva: 0xF8
            /*  F0 */ 0x04,0x01,0x00,0x00, 0x10,0x01,0x00,0x00, 0x02,0x00,0x00,0x00, 0x1A,0x01,0x00,0x00, // EDir.names_rva: 0x104, EDir.ordinal_rva: 0x110, EAddress 1: 0x02 (in module), EAddress 2: 0x11A (fwd)
            /* 100 */ 0x00,0x10,0x00,0x00, 0x16,0x01,0x00,0x00, 0x18,0x01,0x00,0x00, 0x1E,0x01,0x00,0x00, // EAddress 3: 0x1000 (out of module), EName 1: 0x116, EName 2: 0x118, EName 3: 0x11E
            /* 110 */ 0x00,0x00,0x01,0x00, 0x02,0x00,0x41,0x00, 0x42,0x00,0x43,0x2E, 0x44,0x00,0x45,0x00, // EOrdinal 1: 0, EOrdinal 2: 1, EOrdinal 3: 2, Name 1: "A\0", Name 2: "B\0", FwdName: "C.D\0", Name 3: "E\0"
        ];

        parse_exports!(
            ("3 valid exports", Virtual, &[
                ExportNamed {
                    data: ExportData::InModule(&BUFFER[2..]),
                    name: From::from("A".as_bytes()),
                    address_rva: unsafe { &*(BUFFER.as_ptr().add(0xF8) as *const u32) },
                    ordinal: 0
                },
                ExportNamed {
                    data: ExportData::Forwarded(From::from("C.D".as_bytes())),
                    name: From::from("B".as_bytes()),
                    address_rva: unsafe { &*(BUFFER.as_ptr().add(0xFC) as *const u32) },
                    ordinal: 1
                },
                ExportNamed {
                    data: ExportData::OutOfModule(unsafe { BUFFER.as_ptr().add(0x1000) }),
                    name: From::from("E".as_bytes()),
                    address_rva: unsafe { &*(BUFFER.as_ptr().add(0x100) as *const u32) },
                    ordinal: 2
                },
            ], BUFFER)

            // TODO: Add test buffers which test edge cases.
        );
    }

    #[test]
    fn kernel32_exports() {
        let ldr_entry =
            unsafe { crate::process::EnvironmentBlock::current_from_block_teb() }.unwrap()
                .loader_data.as_ref().unwrap()
                // Current process image
                .load_order_next.as_ref().unwrap()
                // ntdll.dll
                .load_order_next.as_ref().unwrap()
                // kernel32.dll
                .load_order_next.as_ref().unwrap();

        let mut parser = ldr_entry.image_base_address.unwrap().create_parser(
            ldr_entry.image_virtual_size, ParsingMode::Virtual
        ).unwrap();

        let mut contains_add_atom_w = false;
        let mut contains_acquire_srw_lock_exclusive = false;

        for export in parser.exports(true).unwrap() {
            match export.data {
                ExportData::InModule(_) => {
                    if export.name == "AddAtomW" {
                        contains_add_atom_w = true;
                    }
                }
                ExportData::OutOfModule(address) => {
                    panic!(
                        "{:?} is most likely hooked to 0x{:X}",
                        export.name.into_lossy(),
                        address as usize
                    );
                }
                ExportData::Forwarded(forwarder) => {
                    if  export.name == "AcquireSRWLockExclusive" &&
                        forwarder == "NTDLL.RtlAcquireSRWLockExclusive"
                    {
                        contains_acquire_srw_lock_exclusive = true;
                    }
                }
            }

            if contains_add_atom_w && contains_acquire_srw_lock_exclusive {
                break;
            }
        }

        assert!(contains_add_atom_w && contains_acquire_srw_lock_exclusive);
    }

    #[test]
    fn parse_virtual() {
        parse![
            ("Invalid DOS size, empty", Virtual, dos_header, false, &[]),
            ("Invalid DOS size, one off", Virtual, dos_header, false, &[
                0x4D,0x5A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Invalid DOS magic", Virtual, dos_header, false, &[
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Correct DOS header", Virtual, dos_header, true, &[
                0x4D,0x5A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),

            (r"Invalid COFF magic, MZ\0\0", Virtual, coff_header, false, &[
                0x4D,0x5A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            (r"Invalid COFF magic \0\0\0\0", Virtual, coff_header, false, &[
                0x4D,0x5A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00
            ]),
            ("Invalid COFF size, one off", Virtual, coff_header, false, &[
                0x4D,0x5A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x45,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x29,0x00,0x00,0x00
            ]),
            ("Valid COFF header", Virtual, coff_header, true, &[
                0x4D,0x5A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x50,0x45,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x28,0x00,0x00,0x00
            ]),

            ("Invalid COFF machine", Virtual, optional_header, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Valid x64 optional header", Virtual, optional_header, true, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Invalid x64 optional header size, field data", Virtual, optional_header, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x6F,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Invalid x64 optional header size, one off", Virtual, optional_header, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Valid x86 optional header", Virtual, optional_header, true, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x4C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x0B,0x01,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Invalid x86 optional header size, field data", Virtual, optional_header, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x4C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x5F,0x00,0x00,0x00,0x0B,0x01,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Invalid x86 optional header size, one off", Virtual, optional_header, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x4C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0x0B,0x01,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Invalid COFF x86 machine + x64 optional header combo", Virtual, optional_header, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x4C,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),
            ("Invalid COFF x64 machine + x86 optional header combo", Virtual, optional_header, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x0B,0x01,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
            ]),

            ("Invalid number of directories", Virtual, directory_export, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00
            ]),
            ("Invalid directory, out of optional header size", Virtual, directory_export, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00
            ]),
            ("Invalid ExportDirectory size, one off", Virtual, directory_export, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x6B,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00
            ]),
            ("Invalid ExportDirectory size, field data", Virtual, directory_export, false, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x27,0x00,
                0x00,0x00
            ]),
            ("Valid ExportDirectory", Virtual, directory_export, true, &[
                0x4D,0x5A,0x50,0x45,0x00,0x00,0x64,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x00,0x0B,0x02,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x28,0x00,
                0x00,0x00
            ])
            /*
                0x4D,0x5A,0x50,0x45,0x00,0x00, Machine ,NrOfSects,0x00,0x00,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,SizOptHdr,Chrctrscs, OHMagic ,0x00,0x00,0x00,0x00,
                0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
	             ExportOrdinalBase , ExportAddressCount,  ExportNamesCount ,ExportAddressTblRVA,
	            ExportNamesTableRVA,ExportOrdinalTblRVA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	            0x00,0x00,0x00,0x00,0x00,0x00,NumberOfDirectories,ExportRelativeVAddr,ExportDire
	            ctorySize
            ])
            */
        ];
    }
}